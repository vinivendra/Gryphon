/*
* Copyright 2018 VinÃ­cius Jorge Vendramini
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// TODO: ifStatement.elseStatement should be GRYASTIfStatement
%{
astNodes = [
	['expression', [['expression', 'GRYExpression']]],
	['typealiasDeclaration',
		[['identifier', 'String'], ['type', 'String'], ['isImplicit', 'Bool']]],
	['extensionDeclaration', [['type', 'String'], ['members', '[GRYTopLevelNode]']]],
	['importDeclaration', [['name', 'String']]],
	['classDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[GRYTopLevelNode]']]],
	['companionObject', [['members', '[GRYTopLevelNode]']]],
	['enumDeclaration',
		[['access', 'String?'], ['name', 'String'], ['inherits', '[String]'],
		['elements', '[GRYASTEnumElement]'], ['members', '[GRYTopLevelNode]'],
		['isImplicit', 'Bool']]],
	['protocolDeclaration', [['name', 'String'], ['members', '[GRYTopLevelNode]']]],
	['structDeclaration',
		[['name', 'String'], ['inherits', '[String]'], ['members', '[GRYTopLevelNode]']]],
	['functionDeclaration',
		[['value', 'GRYASTFunctionDeclaration']]],
	['variableDeclaration',
		[['value', 'GRYASTVariableDeclaration']]],
	['forEachStatement',
		[['collection', 'GRYExpression'], ['variable', 'GRYExpression'],
		['statements', '[GRYTopLevelNode]']]],
	['ifStatement',
		[['value', 'GRYASTIfStatement']]],
	['switchStatement',
		[['convertsToExpression', 'GRYTopLevelNode?'], ['expression', 'GRYExpression'],
		['cases', '[GRYASTSwitchCase]']]],
	['throwStatement', [['expression', 'GRYExpression']]],
	['returnStatement', [['expression', 'GRYExpression?']]],
	['assignmentStatement', [['leftHand', 'GRYExpression'], ['rightHand', 'GRYExpression']]],
	['error'],
	]
}%

public indirect enum GRYTopLevelNode: Equatable, GRYPrintableAsTree {

%for astNode in astNodes:
%	name = astNode[0]
%
%	if len(astNode) > 1:
%		pairs = astNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end

	//
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: self.name)

		switch self {
%for astNode in astNodes:
%	name = astNode[0]
%
%	if len(astNode) > 1:
%		pairs = astNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
		case let .${name}(
				${parametersString}):
%		for pair in pairs:
			try ${pair[0]}.encode(into: encoder)
%		end
%
%	else:
		case .${name}:
			break
%	end
%end
		}

		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> GRYTopLevelNode {
		try decoder.readOpeningParenthesis()
		let name = decoder.readDoubleQuotedString()

		let result: GRYTopLevelNode

		switch name {
%for astNode in astNodes:
%	name = astNode[0]
%
		case "${name}":
%
%	if len(astNode) > 1:
%		pairs = astNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
			let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
			result = .${name}(
				${parametersString})
%
%	else:
			result = .${name}
%	end
%end
		default:
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder, errorMessage: "Unknown GRYTopLevelNode \"\(name)\".")
		}

		try decoder.readClosingParenthesis()
		return result
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO: dictionaryExpression should have key-value pairs
// TODO: callExpression should use GRYASTFunctionDeclaration
%{
expressionNodes = [
	['literalCodeExpression', [['string', 'String']]],
	['templateExpression', [['pattern', 'String'], ['matches', '[String: GRYExpression]']]],
	['parenthesesExpression', [['expression', 'GRYExpression']]],
	['forceValueExpression', [['expression', 'GRYExpression']]],
	['optionalExpression', [['expression', 'GRYExpression']]],
	['declarationReferenceExpression', [['identifier', 'String'], ['type', 'String'],
		['isStandardLibrary', 'Bool'], ['isImplicit', 'Bool']]],
	['typeExpression', [['type', 'String']]],
	['subscriptExpression',
		[['subscriptedExpression', 'GRYExpression'], ['indexExpression', 'GRYExpression'],
		['type', 'String']]],
	['arrayExpression', [['elements', '[GRYExpression]'], ['type', 'String']]],
	['dictionaryExpression', [['keys', '[GRYExpression]'], ['values', '[GRYExpression]'],
		['type', 'String']]],
	['dotExpression',
		[['leftExpression', 'GRYExpression'], ['rightExpression', 'GRYExpression']]],
	['binaryOperatorExpression',
		[['leftExpression', 'GRYExpression'], ['rightExpression', 'GRYExpression'],
		['operatorSymbol', 'String'], ['type', 'String']]],
	['prefixUnaryExpression',
		[['expression', 'GRYExpression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['postfixUnaryExpression',
		[['expression', 'GRYExpression'], ['operatorSymbol', 'String'], ['type', 'String']]],
	['callExpression',
		[['function', 'GRYExpression'], ['parameters', 'GRYExpression'], ['type', 'String']]],
	['closureExpression',
		[['parameters', '[GRYASTLabeledType]'], ['statements', '[GRYTopLevelNode]'],
		['type', 'String']]],
	['literalIntExpression', [['value', 'Int64']]],
	['literalUIntExpression', [['value', 'UInt64']]],
	['literalDoubleExpression', [['value', 'Double']]],
	['literalFloatExpression', [['value', 'Float']]],
	['literalBoolExpression', [['value', 'Bool']]],
	['literalStringExpression', [['value', 'String']]],
	['nilLiteralExpression'],
	['interpolatedStringLiteralExpression', [['expressions', '[GRYExpression]']]],
	['tupleExpression', [['pairs', '[GRYASTLabeledExpression]']]],
	['error'],
]
}%

public indirect enum GRYExpression: Equatable, GRYPrintableAsTree {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	case ${name}(
		${parametersString})
%
%	else:
	case ${name}
%	end
%end

	//
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: self.name)

		switch self {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
		case let .${name}(
				${parametersString}):
%		for pair in pairs:
			try ${pair[0]}.encode(into: encoder)
%		end
%
%	else:
		case .${name}:
			break
%	end
%end
		}

		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> GRYExpression {
		try decoder.readOpeningParenthesis()
		let name = decoder.readDoubleQuotedString()

		let result: GRYExpression

		switch name {
%for expressionNode in expressionNodes:
%	name = expressionNode[0]
%
		case "${name}":
%
%	if len(expressionNode) > 1:
%		pairs = expressionNode[1]
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
			let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end
%		parametersString = ",\n\t\t\t\t".join(parameters)
			result = .${name}(
				${parametersString})
%
%	else:
			result = .${name}
%	end
%end
		default:
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder, errorMessage: "Unknown GRYExpression \"\(name)\".")
		}

		try decoder.readClosingParenthesis()
		return result
	}
}
%{
astElements = [
	['struct', 'GRYASTLabeledExpression',
		[['label', 'String?'], ['expression', 'GRYExpression']]],
	['struct', 'GRYASTLabeledType',
		[['label', 'String'], ['type', 'String']]],
	['struct', 'GRYASTLabeledTypeWithValue',
		[['label', 'String'], ['type', 'String'], ['value', 'GRYExpression?']]],
	['struct', 'GRYASTVariableDeclaration',
		[['identifier', 'String'], ['typeName', 'String'], ['expression', 'GRYExpression?'],
		['getter', 'GRYTopLevelNode?'], ['setter', 'GRYTopLevelNode?'], ['isLet', 'Bool'],
		['isImplicit', 'Bool'], ['isStatic', 'Bool'], ['extendsType', 'String?'],
		['annotations', 'String?']]],
	['struct', 'GRYASTFunctionDeclaration',
		[['prefix', 'String'], ['parameters', '[GRYASTLabeledTypeWithValue]'],
		['returnType', 'String'], ['isImplicit', 'Bool'], ['isStatic', 'Bool'],
		['isMutating', 'Bool'], ['extendsType', 'String?'], ['statements', '[GRYTopLevelNode]?'],
		['access', 'String?']]],
	['class', 'GRYASTIfStatement',
		[['conditions', '[GRYExpression]'], ['declarations', '[GRYASTVariableDeclaration]'],
		['statements', '[GRYTopLevelNode]'], ['elseStatement', 'GRYASTIfStatement?'],
		['isGuard', 'Bool']]],
	['struct', 'GRYASTSwitchCase',
		[['expression', 'GRYExpression?'], ['statements', '[GRYTopLevelNode]']]],
	['struct', 'GRYASTEnumElement',
		[['name', 'String'], ['associatedValues', '[GRYASTLabeledType]']]],
	]
}%
%for astElement in astElements:
%	keyword = astElement[0]
%	name = astElement[1]
%	pairs = astElement[2]

public ${keyword} ${name}: Equatable {
%	for pair in pairs:
	var ${pair[0]}: ${pair[1]}
%	end

%	if keyword == 'class':
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[1])
%		end
%		parametersString = ",\n\t\t".join(parameters)
	public init(
		${parametersString})
	{
%		for pair in pairs:
		self.${pair[0]} = ${pair[0]}
%		end
	}

	public static func == (lhs: GRYASTIfStatement, rhs: GRYASTIfStatement) -> Bool {
%		equalityChecks = []
%		for pair in pairs:
%			equalityChecks.append("lhs." + pair[0] + " == " + "rhs." + pair[0])
%		end
%		equalityChecksString = " &&\n\t\t\t".join(equalityChecks)
		return ${equalityChecksString}
	}

	public func copy() -> GRYASTIfStatement {
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t".join(parameters)
		return GRYASTIfStatement(
			${parametersString})
	}

%	end
	func encode(into encoder: GRYEncoder) throws {
		encoder.startNewObject(named: "${name}")
%	for pair in pairs:
		try ${pair[0]}.encode(into: encoder)
%	end
		encoder.endObject()
	}

	static func decode(from decoder: GRYDecoder) throws -> ${name} {
		try decoder.readOpeningParenthesis()
		let objectName = decoder.readDoubleQuotedString()
		guard objectName == "${name}" else {
			throw GRYDecodingError.unexpectedContent(
				decoder: decoder,
				errorMessage: "Attempted to decode a \(objectName) as a '${name}'.")
		}

%		for pair in pairs:
		let ${pair[0]} = try ${pair[1]}.decode(from: decoder)
%		end

		try decoder.readClosingParenthesis()

		return ${name}(
%		parameters = []
%		for pair in pairs:
%			parameters.append(pair[0] + ": " + pair[0])
%		end
%		parametersString = ",\n\t\t\t".join(parameters)
			${parametersString})
	}
}
%end
